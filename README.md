# Terrenator's readme <img src="https://upload.wikimedia.org/wikipedia/commons/a/ab/Flag_of_Panama.svg" alt="Bandera de Panam√°" width="30"/>
![TERRENATOR (30 x 18 cm) (25 x 6 cm) (1)](https://github.com/user-attachments/assets/5c56937c-a3a7-425d-ac0a-d61c6865f1eb)

[![Facebook](https://img.shields.io/badge/YouTube-%23E4445F.svg?style=for-the-badge&logo=Youtube&logoColor=white)](https://www.youtube.com/@TERRENATORTEAM)
[![Instagram](https://img.shields.io/badge/Instagram-%23E9805F.svg?style=for-the-badge&logo=Instagram&logoColor=white)](https://www.instagram.com/terrenatorteam/)
                
This is the official repository of the TERRENATOR team, which is representing Panama in the World Robotics Olympics (WRO) 2024 to be held this year in Izmir, T√ºrkiye. We chose to participate in the category of Future Engineers this year winning first place in the national robotics olympics in our country. In this repository you can find everything related to the development of our robot.

## Team members üë®‚Äçüíª
> David Rico

> Ericka Ceballos

> Jean Paul Sosa



## Overview of our repository üìú
* `schemes`- contains the circuit diagram.
* `models` - includes all the 3d printed parts of the robot that will go to the international.
* `old models` - includes all the 3d printed parts of the robot that wins in Panama.
* `others`-  This is for other files which can be used to understand the making of the vehicle. 
* `src` - the codes for both challenges, with and without obstacles.
* `t-photos` - photos of the team one formal and a funny one.
* `v-photos` - photos of every angle of the robot, including our previuos version .
* `video` - the link to our youtube channel where you can see our robot in action completing both challenges.
* `README.md` - Here's all our journey in the development of our robot here we explain every part of the robot making.

## Components üß±
A list of all the electrical and mechanical components in the robot.

| <img src="https://github.com/user-attachments/assets/3312d4d8-3a2c-48f9-8fe6-120640876eb5" alt="Alt 1" width="300"/> | <img src="https://github.com/user-attachments/assets/989e28c3-e055-45da-b284-13386d09e14e" alt="Alt 1" width="200"/> | <img src="https://github.com/user-attachments/assets/ddaac9e1-450c-4d3a-bbb0-b5ebca198fa2" alt="Alt 1" width="200"/> | 
| :------------: |:-------------:| :----------:|
|[Arduino NANO A000005 x1](https://store-usa.arduino.cc/products/arduino-nano?srsltid=AfmBOooU4-IrktQwXymxJgaV7MZPj3cBWDjg6AjQwBmYoQw8es2bz9ex)|[LTC1871 Booster Step x1](https://www.amazon.es/ICQUANZX-Converter-3-5-35VDC-Volt%C3%ADmetro-alimentaci%C3%B3n/dp/B07JL39RK2?language=en_GB)|[Step down LM2596 x1](https://a.co/d/e4jJKCS)|
| <img src="https://github.com/user-attachments/assets/b97f68dd-48d3-46a2-872b-7ddec7fb7df7" width="200"/> | <img src="https://github.com/user-attachments/assets/a8fcd7e0-c196-4b7e-b5ac-055d313b8194" alt="Alt 1" width="150"/> | <img src="https://github.com/user-attachments/assets/6791452a-f339-4d2d-ac77-07d16e8cec6d" alt="Alt 1" width="200"/> |
| [Double Sided Prototype Universal PCB Board x2](https://a.co/d/9mUTqVe) |[TB6612 motor driver](https://a.co/d/fpJSHg1)|[HC-SRO4 ultrasonic sensor x3](https://a.co/d/et6RN4v) |
| <img src="https://github.com/user-attachments/assets/22b69b73-122f-42be-bf56-a7297b1bbb23" width="350"/> |<img src="https://github.com/user-attachments/assets/dc905c65-28e3-42ff-bdde-d905bd22bd75" alt="Alt 1" width="200"/>| <img src="https://github.com/user-attachments/assets/dc0bdda4-aeda-43e9-b355-616e628742ca" alt="Alt 1" width="250"/> |
|[POLOLU Metal Gearmotor 25Dx65L mm MP 12V with 48 CPR Encoder x1](https://www.pololu.com/product/4863)|[INJORA 7KG 2065 micro servo motor x1](https://a.co/d/3OIRFif)|[Tosiicop Airsoft Lipo Battery 11.1V x1](https://a.co/d/4mkS5gP)|
| <img src="https://github.com/user-attachments/assets/75af90ba-1501-44d0-9cf9-13ee83422d15" width="250"/> | <img src="https://github.com/user-attachments/assets/1f0feb97-1b34-44a4-a4b9-ae579832d1af" alt="Alt 1" width="300"/> | <img src="https://github.com/user-attachments/assets/166d29d3-77c1-43ee-b914-0fc7dd4190bc" alt="Alt 1" width="200"/> |
|[Pixy cam v2.1 x1](https://a.co/d/hyOCC5F) | 3d structure (you can find the printables in `models`)|[Toggle-Switch SPDT 6A/125VAC x1](https://a.co/d/65AaiQM) |

## Introduction üéì

- For make all the structure of the robot, it took a loot of time and investigation, we decided to build our robot totally by our self, we develop the robot in [OnShape](https://www.onshape.com/en/) Platform , all the design of the robot and all the models and pieces can be found here in `models`, it is compound by 17 parts that together make an assembly. We have passed by a lot of prototypes, we are trying with the turkiye prototype, to make it more light, more smaller, more efficient, we are looking to make the things simple, to make the most efficient freelance car, to control our vehicle, we decided to use [Arduino Nano](https://store.arduino.cc/products/arduino-nano) , because it's smaller and has all that we need to control our robot, we have use a various types of Arduino nano, Like the [Arduino Nano ESP32](https://store.arduino.cc/products/nano-esp32), [Arduino Nano Every](https://store.arduino.cc/products/arduino-nano-every), [Arduino Nano Every](https://store.arduino.cc/products/arduino-nano-every). The reason of why we have used various types of arduino nano, is because everyone of them give different capacities, and sometimes we need different capacities in our robot. To understand the making and the programming of the robot please check all the parts of this `README.md`.

## Vehicle Photos üì∏

| Front           | Right       | Back      |
|:---------------:|:-----------:|:---------:|
| <img width="270" alt="front" src="https://github.com/user-attachments/assets/6f84ca38-0c9e-4d97-ad21-b614274d8c4e"> |<img width="270" alt="front" src="https://github.com/user-attachments/assets/59202f6a-d770-4736-b8df-182cf425b596"> |  <img width="270" alt="front" src="https://github.com/user-attachments/assets/1af8d922-91d6-4d32-9e84-6485ce99b156"> |
| Left          | Top       | Bottom     |
|<img width="270" alt="front" src="https://github.com/user-attachments/assets/3dbc8d78-e1a2-4efd-a434-4e5be9ccd376">| <img width="270" alt="front" src="https://github.com/user-attachments/assets/598fb7a0-45b2-45e9-be24-0b379a4eb9d0"> | <img width="270" alt="front" src="https://github.com/user-attachments/assets/bf297d46-d3c8-4b30-bc6e-63b9df7a281d">|

<br>
 <br>


 > [!NOTE]
>These photos are of the vehicle that will travel to Turkiye to participate in WRO 2024, to see the photos of the car that won the robotics olympics in Panama you can go to the photos folder of the vehicle by clicking [here](https://github.com/kieviceb/TERRENATOR-WRO-2024/tree/main/v-photos)


<br>

## Mobility Strategy üö≤

### 1- Movement

- Motor: Our  gearmotor consists of a medium-power, 12 V brushed DC motor combined with a 20.4:1 metal spur gearbox, and it has an integrated 48 CPR quadrature encoder on the motor shaft, which provides 979.62 counts per revolution of the gearbox‚Äôs output shaft. The gearmotor is cylindrical, with a diameter just under 25 mm, and the D-shaped output shaft is 4 mm in diameter and extends 12.5 mm from the face plate of the gearbox, you can find our motor [here](https://www.pololu.com/product/4863).

<p align="center">
  <img src="https://github.com/user-attachments/assets/01ae8f00-7621-4a3b-9e70-5e3ffdf041cc" alt="Imagen 1" width="500">
</p>


We used a 3D printed traction system in the back axle of the car, is specifically designed to enhance performance and maneuverability. This system involves a set of precisely engineered gears that provide consistent and reliable power transfer from the motor to the rear wheels. The gear configuration ensures that torque is effectively distributed, enabling the car to maintain traction even during rapid acceleration. It provides the power, control, and reliability needed for the commpetition.

### 2- Steering
 
- Steering: The steering is handled by a servomotor, during this project we discovered that using a plastic gear servo is not a good choice, because of the speed of the robot, it tends to break easily inside; thats how we ended up using at first a MG995 servo which is metal gear so it doesnt break so easily, finally for the last prototype to reduce weight and size we found a micro metal gear servo (INJORA 7KG 2065 micro servo motor) , with the power of the big one but weighting less and smaller. Having the steering on the front axle, in vertical position to make movement with more precission.  

<p align="center">
  <img src="https://github.com/user-attachments/assets/f614d79b-fe56-4d9f-9050-d6d1e6774f1a" alt="Imagen 1" width="250">
  <img src="https://github.com/user-attachments/assets/e71c2fbd-4cee-4220-b352-7d41fcfda527" alt="Imagen 2" width="510">
</p>



### 3- Sensors

- [HC-SR04](https://www.sparkfun.com/products/15569):
The HC-SR04 is a distance sensor that uses ultrasound to determine the distance of an object in a range of 2 to 450 cm. It is notable for its small size, low power consumption and good accuracy. The HC-SR04 sensor is the most widely used ultrasonic sensor, mainly due to the amount of information and projects available on the web. It is also the most used in robotics projects such as maze or sumo robots, and in automation projects such as level or distance measurement systems.

This sensor provides 2cm to 400cm of non-contact measurement functionality with a ranging accuracy that can reach up to 3mm. Each HC-SR04 module includes an ultrasonic transmitter, a receiver and a control circuit.

<p align="center">
  <img src="https://github.com/user-attachments/assets/ebde91d6-f7ea-45eb-9816-166295341db8" alt="Imagen 1" width="200">
</p>

-How the HC-SR04 Ultrasonic Distance Sensor Works?
It emits an ultrasound at 40 000 Hz which travels through the air and if there is an object or obstacle on its path It will bounce back to the module. Considering the travel time and the speed of the sound you can calculate the distance.

<p align="center">
<img width="500" alt="AJAJ" src="https://github.com/user-attachments/assets/45b9542d-05ac-4dab-ba9b-becfa1949fe0">
</p>

In order to generate the ultrasound we need to set the Trig pin on a High State for 10 ¬µs. That will send out an 8 cycle ultrasonic burst which will travel at the speed of sound. The Echo pins goes high right away after that 8 cycle ultrasonic burst is sent, and it starts listening or waiting for that wave to be reflected from an object.

To detect the walls with the HC-SR04 it took us a lot of time to figure out a way of using the ultrasonic sensors to avoid the walls successfully, in our previous prototype we had the sensor horizontally and it gave us good lectures most of the time, but not always, thast way investigating a little further and using trigonometry we found out that position the ultrasonic sensors of the sides vertically is way more effective and the main reason we were having trouble at the curves, what was happening was that the TX and RX sides, when reaching the curves, one was further ahead than the other and the pulse did not reach the same place and was sending out erroneous data, therefore when placing them vertically this does not happen, both pulses collide equally, and the signal bounces back uniformly, sending out useful data.

<p align="center">
<img src="https://github.com/user-attachments/assets/da479d5d-0a66-4abc-842d-d36a51ef9c10" alt="Imagen 1" width="500">
</p> 

In addition to this, as can be seen in the photos of the vehicle, our ultrasonic sensors each have a Ceramic capacitor, and before explaining why we have it we should know what it is. A ceramic capacitor is a fixed-value capacitor where the ceramic material acts as the dielectric. It is formed by two or more alternating layers of ceramic and a metallic layer that acts as the electrode. The composition of the ceramic material defines the electrical behavior and therefore the applications.

Knowing this, our intention in placing these ceramic lentils or capacitors is to be able to soften the signals of the ultrasonic sensors, so to speak filter the signals, this helped to not protrude peaks in the sound waves transmitted by the ultrasonic sensor and so that all data are received with the greatest possible clarity.

<p align="center">
<img src="https://github.com/user-attachments/assets/21413d63-e98a-49d5-9c78-977b65c0e008" alt="Imagen 1" width="350">
</p> 

- [MPU-6050](https://invensense.tdk.com/products/motion-tracking/6-axis/mpu-6050/):
MPU6050 sensor module is complete 6-axis Motion Tracking Device. It combines 3-axis Gyroscope, 3-axis Accelerometer and Digital Motion Processor all in small package. Also, it has additional feature of on-chip Temperature sensor. It has I2C bus interface to communicate with the microcontrollers. It has Auxiliary I2C bus to communicate with other sensor devices like 3-axis Magnetometer, Pressure sensor etc. If 3-axis Magnetometer is connected to auxiliary I2C bus, then MPU6050 can provide complete 9-axis Motion Fusion output.
<p align="center">
<img src="https://github.com/user-attachments/assets/f120b572-a1a5-462f-a138-078959369f91" alt="Imagen 1" width="200">
</p> 

- Orientation and polarity of the axes and rotations of the MPU-6050:
It is a 6-axis motion sensor that measures linear accelerations and angular velocities. It uses a three-dimensional coordinate system with axes labeled +X, +Y and +Z, representing forward/backward, left/right and up/down directions, respectively. The +X axis points to the right, +Y points up and +Z points vertically away from the top surface of the sensor, with their negative counterparts in the opposite directions. Rotational motions are measured around these axes, with positive rotation defined by the right-hand rule: if the fingers of the right hand are bent in the direction of rotation, the thumb points along the positive axis. For example, clockwise rotation around the +X (roll), +Y (pitch) or +Z (yaw) axes is considered positive, while counterclockwise rotation is negative. This configuration allows the MPU-6050 to track motion in 3D, making it essential for applications such as balancing robots, drones or any system that requires accurate tracking of motion and orientation.
<p align="center">
<img src="https://github.com/user-attachments/assets/2ade620d-4395-4257-9a37-d1a50e8ead96" alt="Imagen 1" width="200">
</p> 
For our vehicle, we are only interested in the z-axis (Yaw) of the MPU-6050, because this axis is the one that will allow us to determine the desired angles for our robot to work, in our vehicle, we have to let the sensor calibrate to start, at the time of being calibrated the angles that we are interested in are those of 90 degrees to be able to make a right angle turn and to help stabilize the PD, because we had the problem that in the straight lines the PD is well stabilized, but when making the curves it went crazy, and began to oscillate a lot, then to have more precise turns, We used the Z axis (Yaw) of the MPU-6050, but this also had its complications, because the values sent by the z axis were not so simple for the robot to understand, because the first curve, if they were 90 degrees, but the next curve for example the gyroscope threw 180 degrees, and if it is logical, but it was more difficult to implement, so we thought of several possible solutions for this, we thought of resetting or resetting the values of Yaw or the z-axis after each curve, so that if in the serial we can always see that it turns 90 degrees exactly, but this greatly affected the accuracy of the sensor.

 <br>
 <br>


 > [!NOTE]
>In order to see the coding of each motion component or sensor explained, please go to the coding part for further understanding, as well as you can always review the vehicle circuit diagram and review the component list, and also you can check our youtube channel. [Here](https://www.youtube.com/@TERRENATORTEAM)


<br>
In this way, in the vehicle, the MPU-6050 works using the desired angles through functions so that the robot can make precise turns. I will go into much more detail about this in the code section.

### 4- Camera

- [PIXY CAM 2.1](https://pixycam.com/2021/05/20/introducing-pixy-2-1/):
The PixyCam 2.1 is a fast and versatile vision sensor for DIY robotics, offering significant improvements over its predecessor. Its horizontal field-of-view has been expanded to 80 degrees, allowing it to capture more of the environment in each frame, albeit with minor spherical distortion. The camera features a replaceable M12 lens mount with adjustable focus, enabling it to focus on objects as close as 0.25 inches. It also minimizes chromatic distortion at the edges and boasts an F-stop of 2.0, improving light gathering and reducing pixel noise, resulting in higher detection accuracy. Capable of processing images at 60 frames per second, it updates object positions every 16.7 milliseconds, making it ideal for tracking fast-moving objects or precise line-following. The Color Connected Components (CCC) algorithm allows it to detect objects based on hue and saturation, remaining robust under varying lighting conditions. It supports up to 7 unique color signatures or numerous objects using color codes. While retaining the software, firmware, and features of PixyCam 2, this version is slightly larger but significantly more efficient for detection and tracking tasks.

<p align="center">
  <img src="https://github.com/user-attachments/assets/820aed1b-6fa0-4af6-b3b8-ce5495a48d07" alt="Imagen 1" width="330">
  <img src="https://github.com/user-attachments/assets/36c5f9ee-3eb9-4901-be3e-9945540ca827" alt="Imagen 2" width="350">
</p>

## Chasis & 3D Parts

## Code & programming



### 1- Motor:
To begin we need to declare the pins of the motor, exactly is the POLOLU Metal Gearmotor 25Dx65L mm MP 12V with 48 CPR
```ino
int motorPin1 = 5, motorPin2 = 4, enablePin = 3, standbyPin = 16;
```
After this for the correct operation of the motor it is necessary to declare the pins as OUTPUT, that is to declare the pins as output, this is to initialize them, as we will be able to see next in the code:
```ino
pinMode(motorPin1, OUTPUT);
pinMode(motorPin2, OUTPUT);
pinMode(enablePin, OUTPUT);
pinMode(standbyPin, OUTPUT);
digitalWrite(standbyPin, HIGH);
```
Then we will enter the Void functions, which are functions that in determinod time we can call for certain event that we need to occur, in this case the movement of the car, the motorpin 1 in HIGH and motorpin 2 in low makes the motor advance, in case of putting this configuration backwards would make the car go in reverse, and also atravz of the PWM can adjust the speed of the motor, as we can see:
```ino
void avanzar(int velocidad) {
    // Set the motor to rotate in a specific direction.
    digitalWrite(motorPin1, HIGH); // Set motorPin1 to HIGH to define the forward rotation direction.
    digitalWrite(motorPin2, LOW);  // Set motorPin2 to LOW to ensure the motor rotates in the desired direction.
    // Control the motor's speed using PWM (Pulse Width Modulation).
    analogWrite(enablePin, velocidad); // Generate a PWM signal on enablePin to adjust the motor speed (range: 0-255).
}

```
Now we will have the function to stop the motor, that would be with the two pins in LOW, in the code it would be like this:
```ino
void detener() {
    // Stop the motor by cutting power to both motor direction pins.
    digitalWrite(motorPin1, LOW); // Set motorPin1 to LOW to stop the motor.
    digitalWrite(motorPin2, LOW); // Set motorPin2 to LOW to ensure no rotation.

    // Set the speed to zero to fully disable the motor.
    analogWrite(enablePin, 0); // Generate a PWM signal of 0 to turn off the motor.
}
```
Use of the motor in the detectCurve function:

1- During a turn, a fixed speed (250 in PWM) is set to maintain the motion.
2- This command works together with the position of the steering servomotor to perform the turn in a coordinated manner.Use of the motor in the detectCurve function:
```ino
avanzar(250); // Motor control to set a high speed during the rotation.
```



### 2- ServoMotor:

To begin with, we need to declare the library that is made to facilitate its usability in the arduino IDE and optimize it in the code, This line includes the Servo library, which is essential for controlling servo motors on the Arduino. It provides easy-to-use functions, such as attach(), write() and read(), which allow you to control the servo motor angle precisely:
```ino
#include <Servo.h>
```
Declaration of variables related to the servomotor:
Servo servoServoSteer: Create an object of the Servo class called servoDireccionr. This object will be used to configure and control the servo motor in charge of steering the robot.
int pinServo = 6: Defines that the servo motor is connected to the digital pin 6 of the Arduino.
int anguloLeft = 87: Represents the angle at which the servomotor will turn to the left.
int anguloCenter = 90: It is the ‚Äúneutral‚Äù or central angle of the servomotor, where the robot advances in a straight line.
int anguloRight = 105: It is the angle at which the servomotor will turn to the right.
int anguloMPU = 0: A variable used to dynamically adjust the servo motor angle based on the gyroscope data.
```ino
Servo servoDireccion;
int pinServo = 6;
int anguloIzquierda = 87;
int anguloCentro = 90;
int anguloDerecha = 105;
int anguloMPU = 0;
```
servoDirection.attach(pinServo) is used to initialize the servo, which associates the servoDirection object with the pin defined in pinServo (pin 6 in this case). This allows the Arduino to control the servo motor connected to that pin.
This function must be called before attempting to move the servo motor to ensure that the pin is set correctly.servoDirection.attach(pinServo) is used to initialize the servo. It associates the servoDirection object with the pin defined in pinServo (pin 6 in this case). This allows the Arduino to control the servo motor connected to that pin.
This function should be called before attempting to move the servo motor to ensure that the pin is set correctly, look the code to understand:
```ino
void inicializarControlPD() {
    servoDireccion.attach(pinServo);
}
```



### 3- PD (Proportional-Derivative):
Before we explain the coding of this, we need to explain what is it:

PD Control (Proportional-Derivative) is a technique in control theory used to adjust the behavior of a system based on:

-The current error (Proportional): How much the system deviates from the desired value at this moment.
-The rate of change of the error (Derivative): How quickly the error is changing over time.

A PD controller is a simplified form of the PID control, omitting the Integral term. It is useful when:

-Accumulated errors (integral term) do not need to be eliminated.
-The system requires fast and stable responses.

Mathematical Function of PD
The output of the controller (referred to as adjustment or correction) is calculated as:
![null-109](https://github.com/user-attachments/assets/fbdc2763-facf-4c3c-83a6-f9a0d5bbe00e)

where Kp is the proportional gain, Kd the derivative gain, the error the difference between the desired value (setpoint) and the current system value and and d multiplied by the error between d its the Derivative of the error, i.e., the rate of change of the error over time.

-Implementation of PD Control in the code:
The code uses a PD controller to dynamically adjust the servo motor angle based on error. Below, I break down each step of its implementation:

float Kp = 2.0;: Defines the proportional gain.

A higher value means that the system responds more aggressively to error.
Too high a value can make the system unstable (oscillate).
float Kd = 1.0;: Defines the derivative gain.

Helps to smooth the system response. If the error is changing rapidly, this term reduces the setting to avoid oscillations.
float lastError = 0;: Variable to store the error of the previous iteration.
```ino
float Kp = 2.0; // Proportional constant for the PID controller, controls the reaction to the current error.
float Kd = 1.0; // Derivative constant for the PID controller, controls the reaction to the rate of error change.
float lastError = 0; // Stores the previous error value for derivative calculation.
```
Now we have the function to ajust the angles, here is:
```ino
void ajustarAngulo(float error, int anguloDeseado) {
    // Calculate the derivative term (change in error).
    float derivada = error - lastError; // Difference between the current and last error.
    // Compute the adjustment using the PD (Proportional-Derivative) formula.
    float ajuste = (Kp * error) + (Kd * derivada); // PD adjustment based on error and its rate of change.
    // Update the last error for the next iteration.
    lastError = error; 
    // Adjust the desired angle by applying the calculated adjustment.
    anguloDeseado += ajuste; 
    // Constrain the desired angle within the valid range (between anguloIzquierda and anguloDerecha).
    anguloDeseado = constrain(anguloDeseado, anguloIzquierda, anguloDerecha); 
    // Move the servo to the new adjusted angle.
    move_steer(anguloDeseado); 
}

```
We will be explaining it line per line, first we need to calculate the actual error and the last error, this represetn how is changing the mistake or the error in the time, if the error keeps growing quickly it means that this value is more big, and if the mistake it¬¥s getting lower it means it will be lower or cero.
<br>
 <br>


 > [!NOTE]
>Important: The derivative term acts as a ‚Äúbrake‚Äù that reduces the adjustment if the system is already correcting quickly.


<br>

here is the line code:
```ino
float derivada = error - lastError;
```
Now we need to calculate the total ajust, the Kp multiplied bye the error makes a correction that is proportional to the size of the error, meanwhile the mistake it's bigger, more bigger will be the correction. The Kd multiplied by the derivative will make a correction based on the speed of the error change, it helps to get more soft the oscilations.
- By example:
Kp it's equial to 2.0, Kd to 1.0, Error equal 10 and the last error to 8, it means that the derivative will be 10 - 8 = 2,
and the ajust = (2*10)+(1*2)= 20 + 2 = 22, so the final ajust will be 22, let's see it in the code:
```ino
float ajuste = (Kp * error) + (Kd * derivada);
```
Now we have to update the previous error, we use the 'LastError' Variable to update it with the value of the actual error, this is crucial to calculate the derivativee in the next action.
```ino
lastError = error;
```
Now we have to ajust the angle we want, we make this through anguloDeseado += ajuste; this ajust dinamically the angle of the servomotor in function of the result of the PD controlator. and if we do: constrain(anguloDeseado, anguloIzquierda, anguloDerecha); This will limit the angle inside of the fisic values available (anguloIzquierda y anguloDerecha) this prevent damage to the servo.
```ino
anguloDeseado += ajuste;
anguloDeseado = constrain(anguloDeseado, anguloIzquierda, anguloDerecha);
```
Next, we make the movement of the steer applying this line:
```ino
move_steer(anguloDeseado);
```
And for last, we call the PD in the main loop, the PD it's used secuencially inside the main loop or in specific functions like, 'detectarCurva', to fix the direction of the robot, the mistake it's calculated based on the ultrasonic sensors (Desviation due to the center of the way),  with the MPU-6050, and we call 'ajustar angulo' to calculate the new angle in the servomotor to make the correction needed.

### Why do we use PD?:
1- To maintain stability: Avoid abrupt movements or overcorrections that could destabilize the robot.

2- To improve precision: Adjust the steering angle based on real-time data, ensuring that the robot follows the desired path.

3- For smooth motion: Thanks to the derivative term, it reduces oscillations, achieving a smooth ride.

4- For adaptability: Responds dynamically to changes in the environment, such as curves or detours, by adjusting the robot's direction.




### 4- [MPU-6050](https://invensense.tdk.com/products/motion-tracking/6-axis/mpu-6050/):

 First of all we need to initialize our MPU-6050 We need to declare all the variables for it, and it has some specific libraries that you can find it here:

https://github.com/jrowberg/i2cdevlib
https://github.com/ZHomeSlice/Simple_MPU6050
https://github.com/ZHomeSlice/Simple_Wire

And if you don't know how to install it, you need to watch this video, (it's in spanish):

- [MPU-6050  Youtube](https://www.youtube.com/watch?v=TwFZ4BJUX5c&t=1805s)

But i¬¥ll explain here:
First we need to donwload the I2C Library that will make easy the 12c conection with the arduino nano, this library it¬¥s of free software and multiplatform, and this library complement the wire library with the arduino IDE, so, we need to goon the first link i put here and [here](https://github.com/jrowberg/i2cdevlib) then, in the part of code, the green part on the git hub, we will donwnload the zip, so once it is installed we need to extract the file, once it is extracted, we need to go to the 12cdevlib master folder, then the arduino folder, here are a lot of libraries we can use for different proyects, so here we have to search the 12cdev folder, once we find it we have to select it an copy it, so once we do this we have to go to arduino folder, in most of cases it is set default on document, once there we go to libraries and then we paste 12cdev there.

That was our first library, now we need to download the [Simple_MPU6050](https://github.com/ZHomeSlice/Simple_MPU6050)  library, wich this is most simple to use, so we have to intalle the zip of this library, and then in the arduino IDE we have to install the library there, in other words we have to add the zip file to his library inside the IDE.

Even in this part you might have some problems to initialize and use the code, that¬¥s because in the video they dont say this but we need another library, that is for comunication, espacifically the [Simple_Wire](https://github.com/ZHomeSlice/Simple_Wire), to install it you have to follow the same steps of the second library.

Once we have all the libraries needed, we are ready to use the MPU-6050.


First of all, we need to initialize the MPU-6050, we make this including the libraries we previously download, and defining the directions of the gyro.

```ino
#include "Simple_MPU6050.h"
#include <Wire.h>

// Configuraci√≥n MPU6050
#define MPU6050_ADDRESS_AD0_LOW     0x68
#define MPU6050_ADDRESS_AD0_HIGH    0x69
#define MPU6050_DEFAULT_ADDRESS     MPU6050_ADDRESS_AD0_LOW

Simple_MPU6050 mpu;

```
Suddenly we need to calibate the gyro, first we use SetAddres, here we configure the I2C direction of the gyro, Second we use CalibrateMPU, this one calibrates the values of the accelerometer 




## References
- [Git Hub Readme Syntax](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax)
- https://howtomechatronics.com/tutorials/arduino/ultrasonic-sensor-hc-sr04/
- https://www.sparkfun.com/products/15569
- https://invensense.tdk.com/products/motion-tracking/6-axis/mpu-6050/
- https://pixycam.com/2021/05/20/introducing-pixy-2-1/
- https://wro-association.org/wp-content/uploads/WRO-2023-Future-Engineers-Self-Driving-Cars-General-Rules.pdf
- https://www.onshape.com/en/
-https://www.matthewpeterkelly.com/tutorials/pdControl/index.html#:~:text=A%20proportional%2Dderivative%20(PD),car%20at%20some%20desired%20height.
- https://www.youtube.com/watch?v=TwFZ4BJUX5c&t=1805s
- https://grabcad.com/library/pixycam2-case-2
